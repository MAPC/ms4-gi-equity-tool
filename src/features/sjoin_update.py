import numpy as np
import geopandas as gpd
from geopandas import GeoDataFrame
import pandas as pd
from typing import Dict
from shapely.geometry import Polygon
from rasterio.io import MemoryFile

#this is pylusat. Updated to use predicate instead of op to reduce error message

def spatial_join(target_gdf, join_gdf, op="intersects",
                 cols_agg: Dict[str, list] = None,
                 join_type="one to one", keep_all=True):
    """
    Spatial join two GeoDataFrames.
    Parameters
    ----------
    target_gdf, join_gdf : geopandas.GeoDataFrame
        The GeoDataFrame to join to the target GeoDataFrame.
    op : string, default 'intersects'
        Binary predicate, one of {'intersects', 'contains', 'within'}. See
        http://shapely.readthedocs.io/en/latest/manual.html#binary-predicates.
    cols_agg : dict, default None
        Dict of ``{column_name: a list of statistics}``, where the list of
        statistics is a list of strings containing the names of desired
        statistics for each column. Names of the statistics include:
        {'first', 'last', 'sum', 'mean', 'median', 'max', 'min',
        'std', 'var', 'count', 'size'}.
    join_type : string, default 'one to one'
        Binary predicate, one of {'one to one', 'one to many'}. The option
        'one to one' only returns one row for each target feature, whereas
        option 'one to many' return multiple rows for each match between
        target feature and join feature.
    keep_all : bool, default True
        Whether to keep all features from the target GeoDataFrame.
    Returns
    -------
    geopandas.GeoDataFrame
        A GeoDataFrame contains all columns in the target GeoDataFrame and the
        specified columns from the join GeoDataFrame.
    
    Examples
    -------
    >>> pylusat.geotools.spatial_join(acs2016_gdf, schools_gdf, 
                                      cols_agg={'ENROLLMENT': ['sum]})
             GEOID10    ENROLLMENT_SUM
    0   120010006001               0.0
    1   120010006002               0.0
    2   120010006003             345.0
    3   120010007001              37.0
    4   120010007002            1420.0
    ...
    150 120010022191             113.0
    151 120010022192            1889.0
    152 120010022193             118.0
    153 120010022201               0.0
    154 120011108001             803.0
    
    """
    how = 'left' if keep_all else 'inner'
    gpd_sjoin = gpd.sjoin(target_gdf, join_gdf, how=how, predicate=op)

    if join_type.lower() == "one to one":
        sjoin_by_index = gpd_sjoin.groupby(gpd_sjoin.index)

        if cols_agg is None:
            cols_agg = {col: ['first'] for col in join_gdf.columns
                        if col != join_gdf.geometry.name}
            join_df = sjoin_by_index.agg(cols_agg)
            join_df.columns = cols_agg.keys()
        else:
            join_df = sjoin_by_index.agg(cols_agg)
            join_df.columns = [f"{key}_{v}"
                               for key, value in cols_agg.items()
                               for v in set(value)]

        # grab columns of target_gdf
        target_gdf_columns = gpd_sjoin.columns[:len(target_gdf.columns)]
        # remove duplicated rows generated by geopandas spatial join
        # based on columns of target_gdf
        target_df = gpd_sjoin[target_gdf_columns].drop_duplicates()
        return pd.concat([target_df, join_df], axis=1)
    elif join_type.lower() == "one to many":
        return gpd_sjoin
    else:
        raise ValueError("join_type must be either 'one to one' or "
                         "'one to many'")